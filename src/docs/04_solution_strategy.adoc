[[section-solution-strategy]]
== Solution Strategy

=== Introduction

In this section you will find the technology decisions and solutions strategies that we have chosen. Furthermore, we have reasoned why we chose them.

=== Decisions
The project is developed using the following technologies:

[options="header", title="Technologies used for developing"]
|===
| Decision | Purpose | Advantage | Disadvantage
| ReactJS | We will use this JavaScript library to build the user interfaces. | It makes front-end understandable, easy and fast. | At the start of the project, we had no idea nor experience working with React.
| Solid | We have to store the user data in a Solid POD, which will allow us to make the application interoperable and decentralized. | The information of each individual will be managed by each individual. | Solid is still on development and is not easy to work with.
| Node JS | We will use it for modules management. | It offers a wide offer of package via npm. | You have to be careful with the packages that you install as the may have vulnerabilities.
| Organizational decisions | We have decided to work in an incremental way, using a branch dev for all the development of the application. Each functionality will be implemented in a new branch, when we need to commit changes to the dev branch we need to make a pull request. After everything is working on dev, we will make a pull request to master. | We are sure that the final application has less errors, the pull request will ensure the review of other members of the team so they can give you feedback. | You have to be careful when pushing changes and do not forget to make pull requests.
| Test-Driven-Development | We agreed to write the tests first, so this will allow us to work faster when we have to extend the functionality of the application and be always sure if what we are doing is right. | The implementation is previously tested, so you can ensure that the code you are writing is right or wrong. | This approach can slow down development if tests become the main focus and developers try to make them perfect. Full testing might in some places need to be postponed or left as secondary for the aim of delivering on time.
| Travis | Automatically build code, test code and provide and immediate feedback of the success of the changes. | It gives you an automatic feedback of your code, so you don't merge branches that are not mergeable. | Sometimes it may confuse some commit and set them as wrong when they are fine. Also, warnings are treated as errors, so some builds might not pass because of an unused variable, for example.
| CodeCov | Hosted analysis tool which provide statistics about our code coverage. | It gives you an statistical percentage of test coverage of the application. | It was impossible for us to make CodeCov ignore some files to avoid adding them to the statistics of the code coverage.
| Codacy | Write quality code and make it understandable, using the readme for external users understand how the application works and provides information. | It gives you a feedback of the code quality statistics with a grade. | Some marked errors come from a misinterpretation of Codacy about the actual code or from discussed stylistic choices.
| Leaflet | We will use this library for interactive maps. | Open source, free, and easy to integrate. | It is not as well documented as other alternatives as Google Maps.
| PlantUML | Generate diagrams to comprehend a little bit better our solution. | It is a deterministic and easy way to generate diagrams, as they are generated by code | It is not the best design possible
|===

